name: Deploy to Neocities

on:
  push:
    branches:
      - main

concurrency:
  group: deploy-to-neocities
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Generate fresh updates.json from last 20 commits
      - name: Generate updates.json
        env:
          TZ: America/Los_Angeles
        run: |
          MAX=50 # Check more commits to ensure we get 20 non-news entries
          updates=()
          entries_written=0

          while IFS= read -r -d '' sha \
            && IFS= read -r -d '' timestamp \
            && IFS= read -r -d '' full_msg
          do
            sha=$(echo -n "$sha" | tr -d '\n')
            
            subject=$(echo "$full_msg" | head -n1)

            if [[ "$subject" == "!news "* ]]; then
              continue
            fi
            
            if [[ $entries_written -ge 20 ]]; then
              break
            fi

            body=$(echo "$full_msg" | tail -n +2 | sed '/^$/d' | tr '\n' ' ' | sed 's/  */ /g' | sed 's/^ *//;s/ *$//')
            
            if [[ "$subject" == "!rss "* ]]; then
              subject=${subject#"!rss "}
            fi

            title="${subject:-Site Update}"
            message="${body:-$subject}"

            date_fmt=$(TZ="America/Los_Angeles" date -d "@$timestamp" +"%-m/%-d/%Y")
            time_fmt=$(TZ="America/Los_Angeles" date -d "@$timestamp" +"%-l:%M %p")

            esc() { printf "%s" "$1" | sed 's/\\/\\\\/g; s/"/\\"/g; s/\t/\\t/g; s/\r/\\r/g; s/\n/\\n/g'; }
            title_esc=$(esc "$title")
            message_esc=$(esc "$message")

            entry="{\"sha\":\"$sha\",\"title\":\"$title_esc\",\"message\":\"$message_esc\",\"date\":\"$date_fmt\",\"time\":\"$time_fmt\"}"
            updates+=("$entry")
            entries_written=$(( entries_written + 1 ))

          done < <(git log -n $MAX --pretty=format:'%h%x00%ct%x00%B%x00')

          # Join all entries with a comma and newline
          printf "%s" "[" > updates.json
          ( IFS=$',\n'; printf "%s" "${updates[*]}" ) >> updates.json
          printf "\n]\n" >> updates.json
          
          echo "Generated updates.json with $entries_written entries."
        shell: bash



      # Generate news.json from commits with !news flag
      - name: Generate news.json
        env:
          TZ: America/Los_Angeles
        run: |
          MAX=150  # Get last 150 news items
          news_updates=()
          entries_written=0

          while IFS= read -r -d '' sha \
            && IFS= read -r -d '' timestamp \
            && IFS= read -r -d '' full_msg
          do
            sha=$(echo -n "$sha" | tr -d '\n')
            
            subject=$(echo "$full_msg" | head -n1)
            
            if [[ "$subject" != "!news "* ]]; then
              continue
            fi
            
            if [[ $entries_written -ge $MAX ]]; then
              break
            fi
            
            echo "!news flag found, adding to news.json"
            
            subject=${subject#"!news "}
            
            body=$(echo "$full_msg" | tail -n +2 | sed '/^$/d' | tr '\n' ' ' | sed 's/  */ /g' | sed 's/^ *//;s/ *$//')

            title="$subject"
            if [[ -n "$body" ]]; then
              message="$body"
            else
              message="$subject"
            fi

            date_fmt=$(TZ="America/Los_Angeles" date -d "@$timestamp" +"%-m/%-d/%Y")
            time_fmt=$(TZ="America/Los_Angeles" date -d "@$timestamp" +"%-l:%M %p")

            esc() { printf "%s" "$1" | sed 's/\\/\\\\/g; s/"/\\"/g; s/\t/\\t/g; s/\r/\\r/g; s/\n/\\n/g'; }
            title_esc=$(esc "$title")
            message_esc=$(esc "$message")

            entry="{\"sha\":\"$sha\",\"title\":\"$title_esc\",\"message\":\"$message_esc\",\"date\":\"$date_fmt\",\"time\":\"$time_fmt\"}"
            news_updates+=("$entry")
            entries_written=$(( entries_written + 1 ))
          done < <(git log -n 100 --pretty=format:'%h%x00%ct%x00%B%x00')

          printf "%s" "[" > news.json
          ( IFS=$',\n'; printf "%s" "${news_updates[*]}" ) >> news.json
          printf "\n]\n" >> news.json
          
          echo "Generated news.json with $entries_written entries."
        shell: bash

      # Update RSS feed
      - name: Update RSS feed
        env:
          TZ: America/Los_Angeles
        run: |
          # Get the full commit message
          FULL_COMMIT_MSG=$(git log -1 --pretty=format:'%B')
          
          # Get first line as subject
          COMMIT_SUBJECT=$(echo "$FULL_COMMIT_MSG" | head -n1)
          
          # Check if subject starts with !rss
          if [[ "$COMMIT_SUBJECT" != "!rss "* ]]; then
            echo "No !rss flag found in commit message, skipping RSS update"
            exit 0
          fi
          
          # Remove !rss prefix from subject
          TITLE=${COMMIT_SUBJECT#"!rss "}
          
          # Get body (all lines after the first, excluding empty lines)
          BODY=$(echo "$FULL_COMMIT_MSG" | tail -n +2 | sed '/^$/d')
          
          # If no body provided, use the title as the message
          if [[ -z "$BODY" ]]; then
            MESSAGE="$TITLE"
          else
            MESSAGE="$BODY"
          fi
          
          # Get commit date first (needed for initial RSS creation)
          COMMIT_DATE=$(date -R)
          
          # Try to download current RSS
          if ! curl -f -o current-rss.xml https://kingposs.com/rss.xml; then
            echo "WARNING: Could not download RSS from site"
            
            # Check if this might be the first time (no RSS exists yet)
            if curl -s -o /dev/null -w "%{http_code}" https://kingposs.com/rss.xml | grep -q "404"; then
              echo "RSS file doesn't exist on site yet, creating initial RSS"
              {
                echo '<?xml version="1.0" encoding="UTF-8"?>'
                echo '<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">'
                echo '  <channel>'
                echo '    <title>The Possum Den</title>'
                echo '    <link>https://kingposs.com</link>'
                echo '    <description>Combined feed from blog, knowledge base, and main site</description>'
                echo '    <language>en-us</language>'
                echo "    <lastBuildDate>$COMMIT_DATE</lastBuildDate>"
                echo '    <atom:link href="https://kingposs.com/rss.xml" rel="self" type="application/rss+xml"/>'
                echo '  </channel>'
                echo '</rss>'
              } > current-rss.xml
            else
              echo "Download failed for unknown reason, skipping RSS update"
              rm -f current-rss.xml
              exit 0
            fi
          fi
          
          echo "Successfully downloaded/created RSS base"
          
          # Get the latest commit info
          COMMIT_SHA=$(git rev-parse HEAD)
          
          # Get list of changed HTML files only
          CHANGED_FILES=$(git diff-tree --no-commit-id --name-only -r HEAD | grep -E '\.html?$' | head -10)
          
          # Create the new RSS item with proper escaping and indentation
          NEW_ITEM="    <item>"
          NEW_ITEM="${NEW_ITEM}\n      <title>The Den: ${TITLE}</title>"
          NEW_ITEM="${NEW_ITEM}\n      <link>https://kingposs.com</link>"
          NEW_ITEM="${NEW_ITEM}\n      <description><![CDATA["
          
          # Format the body/message - convert newlines to spaces for single-line RSS display
          FORMATTED_MESSAGE=$(echo "$MESSAGE" | tr '\n' ' ' | sed 's/  */ /g')
          NEW_ITEM="${NEW_ITEM}\n<p>${FORMATTED_MESSAGE}</p>"
          
          # Only add the file list if there are HTML files
          if [[ -n "$CHANGED_FILES" ]]; then
            NEW_ITEM="${NEW_ITEM}\n<p><strong>Updated pages:</strong></p>"
            NEW_ITEM="${NEW_ITEM}\n<ul>"
            
            while IFS= read -r file; do
              if [[ -n "$file" ]]; then
                NEW_ITEM="${NEW_ITEM}\n<li><a href=\"https://kingposs.com/${file}\">${file}</a></li>"
              fi
            done <<< "$CHANGED_FILES"
            
            NEW_ITEM="${NEW_ITEM}\n</ul>"
          fi
          
          NEW_ITEM="${NEW_ITEM}\n]]></description>"
          NEW_ITEM="${NEW_ITEM}\n      <pubDate>${COMMIT_DATE}</pubDate>"
          NEW_ITEM="${NEW_ITEM}\n      <guid>https://kingposs.com/update/${COMMIT_SHA}</guid>"
          NEW_ITEM="${NEW_ITEM}\n    </item>"
          
          # Insert new item into RSS - after the atom:link element  
          # Use echo -e to interpret the \n characters
          echo -e "$NEW_ITEM" > temp_item.xml
          awk '/atom:link.*\/>/ && !done {print; while((getline line < "temp_item.xml") > 0) print line; done=1; next} 1' current-rss.xml > rss.xml
          rm -f temp_item.xml
          
          # Update lastBuildDate
          sed -i "s|<lastBuildDate>.*</lastBuildDate>|<lastBuildDate>$COMMIT_DATE</lastBuildDate>|" rss.xml
          
          # Clean up
          rm -f current-rss.xml
          
          echo "RSS updated successfully"

      # Prepare deployment folder
      - name: Prepare deployment folder
        run: |
          mkdir deploy
          rsync -av --exclude='.git' --exclude='.github' --exclude='.gitignore' --exclude='README.md' --exclude='*.scss' ./ deploy/

      # Remove sourceMappingURL from CSS files
      - name: Remove sourceMappingURL from CSS files
        run: |
          find deploy -type f -name "*.css" -exec sed -i 's/\/\*# sourceMappingURL=[^*]*\*\///g' {} \;

      # Deploy to Neocities
      - name: Deploy to Neocities
        uses: bcomnes/deploy-to-neocities@v3
        with:
          api_key: ${{ secrets.NEOCITIES_API_TOKEN }}
          cleanup: false
          protected_files: "{assets,json,blog,Thoughts,JS,tags}/**"
          neocities_supporter: true
          preview_before_deploy: true
          dist_dir: "deploy"